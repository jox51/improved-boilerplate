<?php

namespace App\Http\Controllers;

use App\Http\Requests\ArvowWebhookRequest;
use App\Models\Post;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class ArvowWebhookController extends Controller
{
    /**
     * Handle incoming Arvow webhook requests.
     *
     * @param ArvowWebhookRequest $request
     * @return JsonResponse
     */
    public function handleWebhook(ArvowWebhookRequest $request): JsonResponse
    {
        try {
            // Validate the secret header
            if (!$this->validateSecret($request)) {
                Log::warning('Arvow webhook failed secret validation', [
                    'ip' => $request->ip(),
                    'user_agent' => $request->userAgent(),
                ]);
                return response()->json(['error' => 'Unauthorized'], 401);
            }

            // Process the webhook data (validation is handled by ArvowWebhookRequest)
            $post = $this->processWebhookData($request->validated());
            Log::info('Arvow webhook processed successfully', [
                'post' => $post,
            ]);

            // Generate the post URL
            $postUrl = url('/blog/' . $post->slug);

            Log::info('Arvow webhook processed successfully', [
                'arvow_id' => $post->arvow_id,
                'post_id' => $post->id,
                'post_slug' => $post->slug,
                'post_url' => $postUrl,
            ]);

            return response()->json(['url' => $postUrl], 200);

        } catch (\Exception $e) {
            Log::error('Arvow webhook processing failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'payload' => $request->all(),
            ]);

            return response()->json(['error' => 'Internal server error'], 500);
        }
    }

    /**
     * Validate the X-SECRET header against the configured secret.
     *
     * @param Request $request
     * @return bool
     */
    private function validateSecret(Request $request): bool
    {
        $providedSecret = $request->header('X-SECRET');
        $expectedSecret = env('ARVOW_WEBHOOK_SECRET');

        if (empty($expectedSecret)) {
            Log::error('ARVOW_WEBHOOK_SECRET not configured');
            return false;
        }

        return hash_equals($expectedSecret, $providedSecret ?? '');
    }


    /**
     * Process the validated webhook data and create/update the post.
     *
     * @param array $data
     * @return Post
     */
    private function processWebhookData(array $data): Post
    {
        // Map Arvow fields to Post model fields
        $postData = [
            'arvow_id' => $data['id'],
            'title' => $data['title'],
            'content' => $data['content'],
            'content_markdown' => $data['content_markdown'] ?? null,
            'tags' => $data['tags'] ?? null,
            'thumbnail_url' => $data['thumbnail'] ?? null,
            'thumbnail_alt_text' => $data['thumbnail_alt_text'] ?? null,
            'meta_description' => $data['metadescription'] ?? null,
            'keyword_seed' => $data['keyword_seed'] ?? null,
            'language_code' => $data['language_code'] ?? 'en',
            'status' => 'published',
            'published_at' => now(),
            'user_id' => 1, // Default admin user ID for Arvow posts
        ];

        // Generate excerpt from content if not provided
        if (empty($postData['excerpt'])) {
            $postData['excerpt'] = Str::limit(strip_tags($postData['content']), 150);
        }

        // Use updateOrCreate to handle both new posts and updates
        $post = Post::updateOrCreate(
            ['arvow_id' => $data['id']], // Search condition
            $postData // Data to create or update
        );

        // The slug is automatically generated by the setTitleAttribute mutator
        // but we need to ensure it's unique for updates where the title changed
        if (!$post->wasRecentlyCreated && $post->wasChanged('title')) {
            $post->slug = Post::generateUniqueSlug($post->title, $post->id);
            $post->save();
        }

        return $post;
    }
}